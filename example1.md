**1. Название темы**  
*Реляционная модель данных: преимущества, ограничения и современные расширения*

**2. Краткое описание темы**  
Тема охватывает фундаментальные принципы реляционной модели данных, её исторический контекст и ключевые достоинства (структурированность, поддержка SQL, целостность данных). Далее рассматриваются ограничения модели в условиях сложных взаимосвязей, больших данных и слабоструктурированных форматов. Особое внимание уделяется современным расширениям – объектно‑реляционным типам, хранению JSON и другим документно‑ориентированным возможностям, а также критическому сравнению реляционных СУБД с иерархическими, сетевыми, объектными и документными моделями.

**3. Подтемы / шаги изучения**

1. **История и основы реляционной модели**  
   - Появление модели (E.F. Codd, 1970‑е годы)  
   - Ключевые понятия: таблицы, строки, столбцы, первичные/внешние ключи  
   - Математический фундамент: теория множеств и отношения  

2. **Преимущества реляционных СУБД**  
   - Строгая структура и упрощённое обслуживание  
   - Стандарт SQL как декларативный язык запросов  
   - Эффективность модифицирующих операций (INSERT/UPDATE/DELETE)  
   - Гарантии целостности данных (ACID‑принципы)  

3. **Ограничения и сложности**  
   - Сложность схем при большом количестве произвольных связей  
   - Трудности обеспечения целостности в распределённых системах  
   - Ограничения математической теории множеств в реальных задачах  
   - Проблемы масштабирования и производительности при массовой выборке  

4. **Объектно‑реляционные расширения**  
   - Пользовательские типы данных (структурные, коллекции)  
   - Интеграция объектных моделей в реляционные СУБД (PostgreSQL, Oracle)  
   - Плюсы и минусы «объектно‑реляционных» систем  

5. **Слабоструктурированные данные и JSON**  
   - Определение слабоструктурированных данных  
   - Теги, маркеры и иерархическая структура  
   - Потеря соответствия: разница между пользовательским интерфейсом и реляционной схемой  
   - Поддержка JSON в реляционных СУБД и её влияние на модель  

6. **Большие данные и распределённые системы**  
   - Роль реляционных таблиц в системах Big Data  
   - Плюсы и минусы жесткой структуры при больших объёмах  
   - Современные подходы к хранению и обработке больших данных (Hadoop, Spark, NoSQL‑подобные решения)  

7. **Сравнение с другими моделями данных**  
   - Иерархическая и сетевая модели  
   - Объектные базы данных (почему они не вытеснили реляцию)  
   - Документно‑ориентированные СУБД (MongoDB, Couchbase)  
   - Критерии выбора модели для конкретных задач  

8. **Практические рекомендации**  
   - Когда оставаться в рамках реляционной модели  
   - Когда использовать расширения (JSON, объектно‑реляционные типы)  
   - Как балансировать между структурой и гибкостью  
   - Лучшие практики миграции и интеграции слабоструктурированных данных  

Эта структура позволит последовательно изучить как классические принципы реляционной модели, так и её современные варианты, а также понять, в каких случаях стоит выбирать альтернативные модели данных.
**1. Название темы**  
*Основы больших данных (Big Data): характеристики, принципы и технологии*

**2. Краткое описание темы**  
Тема охватывает фундаментальные понятия и практики работы с большими данными. В ней рассматриваются ключевые характеристики (Volume, Velocity, Variety, Veracity, Value, Variability), основные принципы обработки (горизонтальная масштабируемость, отказоустойчивость, локальность данных), а также современный технологический стек (NoSQL‑базы, Hadoop, MapReduce, Spark, Kafka). Приводятся примеры применения в различных отраслях (медицина, промышленность, IoT, астрономия) и обсуждаются вызовы и перспективы развития.

**3. Подтемы / шаги изучения**

| № | Подтема | Краткое содержание |
|---|---------|---------------------|
| 1 | **Классификация больших данных** | 3V (Volume, Velocity, Variety) + 4V (Veracity) + Value, Variability |
| 2 | **Принципы работы с Big Data** | Горизонтальная масштабируемость, отказоустойчивость, локальность данных |
| 3 | **Технологический стек** | Реляционные СУБД vs NoSQL, Hadoop (HDFS, MapReduce), Spark, Kafka, Flink |
| 4 | **Архитектуры хранения и обработки** | Распределённые файловые системы, колоночные БД, графовые БД, edge‑computing |
| 5 | **Методы анализа** | Статистический анализ, машинное обучение, визуализация, predictive analytics |
| 6 | **Применения в отраслевых кейсах** | Здравоохранение, промышленность, финансы, IoT, астрономия, биоинформатика |
| 7 | **Проблемы и решения** | Качество и достоверность данных, безопасность, GDPR, масштабирование, хранение |
| 8 | **Тенденции и будущее** | Edge‑analytics, квантовые вычисления, AI‑driven analytics, новые модели данных |

Эта структура позволяет последовательно погрузиться в теорию, практику и перспективы работы с большими данными.
**1. Название темы**  
*Механизмы надёжности и параллельности в системах управления базами данных (СУБД)*  

**2. Краткое описание темы**  
В данной теме рассматриваются ключевые принципы и технологии, которые позволяют СУБД обеспечивать корректное, безопасное и высокопроизводительное хранение и обработку данных. Особое внимание уделяется буферизации, метаданным, журналированию, резервному копированию, восстановлению после сбоев, управлению параллельным доступом и сетевому взаимодействию. Понимание этих механизмов позволяет проектировать и администрировать базы данных, гарантируя целостность, доступность и отказоустойчивость.

**3. Подтемы / шаги изучения**

| № | Подтема | Краткое содержание |
|---|---------|---------------------|
| 1 | **Буферизация данных** | Механизмы кэширования страниц, стратегии чтения/записи, влияние на производительность. |
| 2 | **Метаданные и системный каталог** | Структура каталога, хранение описаний таблиц, индексов, связей, ограничений и прав пользователей. |
| 3 | **Журналирование (логирование) изменений** | Форматы журналов, транзакционные журналы, ACID‑свойства, роль в восстановлении. |
| 4 | **Резервное копирование и восстановление** | Полные, инкрементные и дифференциальные бэкапы, стратегии восстановления, тестирование. |
| 5 | **Надёжность хранения** | Физические уровни хранения, RAID, избыточность, проверка целостности данных. |
| 6 | **Управление параллельностью** | Механизмы блокировок, уровни изоляции транзакций, оптимистический и пессимистический контроль. |
| 7 | **Многопользовательский доступ** | Аутентификация, авторизация, разграничение прав, предотвращение конфликтов. |
| 8 | **Обеспечение целостности данных** | Ограничения (PRIMARY KEY, FOREIGN KEY, CHECK), триггеры, бизнес‑правила. |
| 9 | **Сетевой доступ и обмен данными** | Протоколы (TCP/IP, JDBC/ODBC), клиент‑серверные модели, безопасность соединений. |
|10 | **Практические кейсы и инструменты** | Конфигурация популярных СУБД (PostgreSQL, MySQL, Oracle, SQL Server), мониторинг, аудит. |

Эти шаги можно изучать последовательно, начиная с фундаментальных понятий буферизации и метаданных, и переходя к более сложным темам, таким как управление параллельностью и восстановление после сбоев. Каждый пункт можно дополнить лабораторными заданиями, демонстрациями и анализом реальных сценариев эксплуатации баз данных.
**1. Название темы**  
*JSON и JSONB в реляционных базах данных*

**2. Краткое описание темы**  
В этой теме рассматриваются особенности хранения, обработки и индексации данных в формате JSON и его бинарной версии JSONB в современных реляционных СУБД (MySQL, PostgreSQL и др.). Погружаемся в принципы работы с «слабо‑структурированными» данными, сравниваем текстовый и бинарный варианты, изучаем встроенные функции, возможности индексации и влияние на производительность. Также рассматриваем практические сценарии использования JSON/JSONB в сочетании с традиционными реляционными моделями и альтернативными бинарными форматами (Protobuf, MessagePack).

**3. Подтемы / шаги изучения**

| № | Подтема | Краткое содержание |
|---|---------|---------------------|
| 1 | Введение в JSON | Структура, типы данных, синтаксис, примеры документов. |
| 2 | JSON в реляционных БД | Как СУБД представляют JSON как тип данных, хранение в таблицах. |
| 3 | JSON vs JSONB | Текстовый vs бинарный формат: разбор, преобразование, влияние на ввод/вывод. |
| 4 | Индексация JSONB | Создание индексов, типы индексов, влияние на запросы. |
| 5 | Функции работы с JSON/JSONB | Встроенные функции (конвертация, извлечение, обновление), примеры запросов. |
| 6 | Сравнение с XML | Плюсы/минусы, совместимость, XPath/XQuery vs SQL/JSON Path. |
| 7 | Хранение «без схемы» | Денормализация, гибкость структуры, управление целостностью. |
| 8 | Бинарные альтернативы | Protobuf, MessagePack, их преимущества и сценарии использования. |
| 9 | Практические кейсы | Примеры из реальных проектов: хранение логов, метаданных, динамических форм. |
|10 | Оптимизация производительности | Кеширование, парсинг, выбор типа данных, настройка индексов. |
|11 | Безопасность и контроль целостности | Ограничения, валидация схем, ограничения в СУБД. |
|12 | Интеграция с приложениями | Работа с драйверами, сериализация/десериализация, ORM‑поддержка. |

Эта структура позволит последовательно освоить теорию и практику работы с JSON/JSONB, а также понять, когда и как использовать каждый из вариантов в реальных проектах.
**1. Название темы**  
*Потоковая и пакетная обработка больших данных: архитектуры и инструменты*

**2. Краткое описание темы**  
В рамках данной темы рассматриваются ключевые подходы к обработке больших данных, которые позволяют обрабатывать как огромные батчи, так и непрерывные потоки событий с минимальной задержкой. Мы изучим фундаментальные принципы MapReduce и Hadoop, современные решения для in‑memory вычислений (Apache Spark), а также системы обмена сообщениями (Kafka, RabbitMQ). Особое внимание уделяется архитектуре Lambda, объединяющей пакетную и потоковую обработку, и её микробатч‑вариантам. В конце темы будет показан практический пример построения end‑to‑end pipeline, включающего ingestion, stream‑processing, хранение аналитических данных и генерацию отчетов.

**3. Подтемы / шаги изучения**

| № | Подтема | Краткое содержание |
|---|---------|---------------------|
| 1 | **Введение в большие данные** | Понятие «big data», основные требования (volume, velocity, variety, veracity). |
| 2 | **Пакетная обработка** | MapReduce, Hadoop Distributed File System (HDFS), Spark в режиме batch, преимущества и ограничения. |
| 3 | **Сбор и хранение сообщений в реальном времени** | Message brokers (Kafka, RabbitMQ), publish/subscribe, горизонтальное масштабирование, отказоустойчивость. |
| 4 | **Потоковая обработка** | Spark Streaming, Apache Storm, micro‑batch vs true streaming, latency‑throughput trade‑offs. |
| 5 | **Хранилище аналитических данных** | OLAP‑схемы, колонно‑ориентированные хранилища (Parquet, ORC), подготовка данных к BI. |
| 6 | **Аналитика и отчётность** | OLAP‑операции, dashboards, интеграция с BI‑инструментами (Tableau, Power BI). |
| 7 | **Lambda‑архитектура** | Три уровня (batch, speed, serving), микробатчинг, объединение результатов, примеры реализации. |
| 8 | **Сравнение подходов** | Latency, throughput, consistency, fault‑tolerance, cost‑efficiency. |
| 9 | **Практический pipeline** | Конфигурация: Kafka → Spark Streaming → HDFS → Spark SQL → BI‑dashboard. |
|10 | **Масштабирование и отказоустойчивость** | Репликация брокеров, распределённые файловые системы, балансировка нагрузки, мониторинг. |
|11 | **Альтернативы и тренды** | Kappa‑архитектура, Apache Flink, Google Dataflow/Beam, serverless‑решения. |

Эта структура позволяет последовательно перейти от теоретических основ до практической реализации, охватывая все ключевые компоненты современной экосистемы обработки больших данных.
**1. Название темы**  
Клиент‑серверные и встроенные СУБД  

**2. Краткое описание темы**  
В этой теме рассматриваются два основных подхода к организации систем управления базами данных: клиент‑серверная модель, где данные хранятся и обрабатываются на центральном сервере, и встроенная модель, где СУБД интегрирована в приложение как библиотека. Обсуждаются архитектурные особенности, преимущества и ограничения каждой модели, роль SQL как универсального языка общения, вопросы целостности, безопасности, масштабируемости и администрирования.  

**3. Подтемы / шаги изучения**  

1. **Введение в СУБД**  
   - Что такое система управления базами данных  
   - Основные функции: хранение, манипуляция, безопасность, администрирование  

2. **Клиент‑серверная модель**  
   - Архитектура: клиент, сервер, сеть  
   - Как клиент формирует запросы (SQL) и получает ответы  
   - Параллельная многопользовательская обработка  
   - Централизованное хранение и единые правила безопасности  
   - Преимущества: доступность, масштабируемость, стандартизация  
   - Недостатки: нагрузка на сервер, требования к производительности  

3. **Встроенная (embedded) модель**  
   - Что такое встроенная СУБД и где она используется (почтовые клиенты, мессенджеры)  
   - Физическая реализация как библиотека  
   - Доступ к данным: SQL и специализированные API  
   - Плюсы: низкие требования к ресурсам, высокая скорость, компактность  
   - Ограничения: отсутствие коллективного доступа, ограниченные возможности администрирования  

4. **SQL как универсальный язык общения**  
   - Стандарт SQL и его роль в обеспечении совместимости  
   - Примеры запросов: SELECT, INSERT, UPDATE, DELETE  

5. **Целостность и безопасность данных**  
   - Правила целостности, транзакции, откат  
   - Как сервер обеспечивает соблюдение правил  

6. **Масштабируемость и производительность**  
   - Горизонтальная масштабируемость клиент‑серверных систем  
   - Оптимизация запросов, индексы, кэширование  

7. **Администрирование и поддержка**  
   - Инструменты мониторинга, статистики, экспорта/импорта  
   - Службы аудита, реорганизация файлов и индексов  

8. **Сравнительный анализ**  
   - Критерии выбора модели для конкретного проекта  
   - Примеры сценариев: корпоративные приложения, мобильные устройства, IoT  

9. **Практическая часть**  
   - Установка и настройка клиент‑серверной СУБД (например, PostgreSQL, MySQL)  
   - Интеграция встроенной СУБД (SQLite, H2) в простое приложение  
   - Написание и выполнение SQL‑запросов, тестирование производительности  

10. **Тенденции и будущее**  
    - Новые технологии: облачные СУБД, NoSQL, NewSQL  
    - Как клиент‑серверные и встроенные модели адаптируются к современным требованиям  

---  

Эта структура позволит последовательно изучить ключевые аспекты обеих моделей СУБД, понять их взаимосвязи и научиться выбирать оптимальный подход для конкретных задач.
**1. Название темы**  
*Изоляция транзакций: уровни и проблемы совместного доступа к данным*

**2. Краткое описание темы**  
В этой теме рассматриваются основные проблемы, которые возникают при параллельном выполнении транзакций в системах управления базами данных, и способы их решения с помощью уровней изоляции. Мы изучим понятия «грязное чтение», «неповторяющееся чтение», «фантомное чтение» и «потерянное обновление», а также проанализируем, как уровни изоляции READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ и SERIALIZABLE защищают данные от этих конфликтов. В конце темы будут приведены практические рекомендации по выбору уровня изоляции в зависимости от требований к целостности и производительности.

**3. Подтемы / шаги изучения**

| Шаг | Подтема | Краткое содержание |
|-----|---------|---------------------|
| 1 | **Основы транзакций и изоляции** | Что такое транзакция, ACID‑свойства, зачем нужна изоляция. |
| 2 | **Проблемы параллельного доступа** | • Грязное чтение (dirty read) – чтение незавершённых изменений.<br>• Неповторяющееся чтение (non‑repeatable read) – изменение данных между двумя чтениями.<br>• Фантомное чтение (phantom read) – появление/удаление строк в диапазоне.<br>• Потерянное обновление (lost update) – переписывание изменений. |
| 3 | **Уровни изоляции** | • READ UNCOMMITTED – наименее защищённый.<br>• READ COMMITTED – исключает грязное чтение.<br>• REPEATABLE READ – предотвращает неповторяющееся чтение.<br>• SERIALIZABLE – полностью изолирует, предотвращает фантомы. |
| 4 | **Как каждый уровень защищает от конкретных проблем** | Сравнение: какие проблемы устраняются на каждом уровне, примеры SQL‑запросов. |
| 5 | **Таблица примеров** | Анализ таблицы 10.4 (баланс Alice) и других сценариев. |
| 6 | **Плюсы и минусы уровней** | Влияние на производительность, блокировки, конкуренцию, вероятность откатов. |
| 7 | **Выбор уровня изоляции** | Критерии: требования к целостности, нагрузка, тип транзакций, бизнес‑логика. |
| 8 | **Практические паттерны** | • Оптимистичная и пессимистичная блокировка.<br>• MVCC (Multi‑Version Concurrency Control).<br>• Тестирование конфликтов и мониторинг. |
| 9 | **Рекомендации по настройке** | Как настроить уровень изоляции в популярных СУБД (PostgreSQL, MySQL, Oracle, SQL Server). |
| 10 | **Заключение и дальнейшее чтение** | Краткое резюме, ссылки на официальную документацию и литературу. |

Эта структура поможет последовательно освоить тему, от теоретических основ до практических навыков выбора и настройки уровней изоляции в реальных проектах.
**1. Название темы**  
*История и стандартизация SQL: от ANSI/ISO до современных диалектов*

**2. Краткое описание темы**  
В этой теме рассматривается развитие языка SQL как стандарта для работы с реляционными базами данных. Мы изучим, как и почему возникли международные стандарты ANSI/ISO, какие ключевые версии (SQL‑89, SQL‑92, SQL‑99, SQL‑2003, SQL‑2008, SQL‑2011, SQL‑2016 и далее) определяли синтаксис и семантику, и как производители СУБД вносили собственные расширения, создавая диалекты. Тема также охватывает преимущества и ограничения стандарта, влияние диалектов на переносимость кода, а также перспективы развития SQL в контексте современных требований к данным (JSON, XML, графовые данные, облачные сервисы).

**3. Подтемы / шаги изучения**

| Шаг | Подтема | Ключевые вопросы |
|-----|---------|------------------|
| 1 | **Первые шаги: SQL‑89 и первые стандарты** | Что такое ANSI/ISO, как был сформирован первый стандарт, какие основные конструкции были включены? |
| 2 | **SQL‑92: «первый «полноценный» стандарт»** | Какие новые возможности появились, почему SQL‑92 стал «общепризнанным»? Как это повлияло на разработку СУБД? |
| 3 | **Эволюция: SQL‑99, SQL‑2003, SQL‑2008, SQL‑2011, SQL‑2016** | Какие ключевые расширения (например, CTE, XML, JSON, оконные функции) добавились в каждой версии? Как они изменили способ работы с данными? |
| 4 | **Диалекты и «отступления» от стандарта** | Почему производители добавляют собственные расширения? Какие самые известные диалекты (Oracle PL/SQL, Microsoft T‑SQL, PostgreSQL, MySQL, SQLite)? Как они влияют на переносимость кода? |
| 5 | **Преимущества и ограничения стандарта** | Что делает SQL декларативным, как это упрощает разработку? Какие сложности возникают при работе с иерархическими структурами, хранимыми процедурами, триггерами? |
| 6 | **Совместимость и тестирование** | Какие существуют стандарты тестирования совместимости (SQL:2003, SQL:2008, SQL:2011)? Как они помогают «стабилизировать» язык? |
| 7 | **Будущее SQL** | Как современные требования (NoSQL, графовые данные, облачные сервисы) влияют на развитие SQL? Что ожидается в будущих версиях стандарта? |
| 8 | **Практическое применение** | Как писать переносимый код, используя только стандартизированные конструкции? Как использовать диалектные расширения, не нарушая переносимость? |

Эта структура позволит последовательно погрузиться в историю, технические детали и практические аспекты работы с SQL‑стандартами и их диалектами.
**1. Название темы**  
Ссылочная целостность в реляционных БД  

**2. Краткое описание темы**  
Тема посвящена принципу ссылочной целостности – гарантии того, что все внешние ключи в базе данных указывают на существующие записи в родительских отношениях. Рассматриваются понятия потенциального и внешнего ключа, типы отношений «один‑ко‑многим», а также последствия операций вставки, обновления и удаления как в родительских, так и в дочерних таблицах. Включены правила работы с NULL‑значениями, механизмы автоматического реагирования (CASCADE, SET NULL, RESTRICT) и рекомендации по проектированию схемы для предотвращения нарушений целостности.  

**3. Подтемы / шаги изучения**  

1. **Основы ссылочной целостности**  
   - Что такое внешние и потенциальные ключи  
   - Правило «внешний ключ → существующий первичный ключ»  

2. **Родительские и дочерние отношения**  
   - Определение «родительского» и «дочернего» отношения  
   - Типы связей: один‑ко‑многим, один‑ко‑одному, многие‑ко‑многим  

3. **Влияние операций на целостность**  
   - Вставка, обновление, удаление в родительском отношении  
   - Вставка, обновление, удаление в дочернем отношении  

4. **NULL‑значения и внешние ключи**  
   - Когда допускается NULL в внешнем ключе  
   - Ограничения, если атрибуты внешнего ключа входят в состав потенциального ключа  

5. **Механизмы обеспечения целостности**  
   - ON DELETE / ON UPDATE: CASCADE, SET NULL, SET DEFAULT, RESTRICT, NO ACTION  
   - Примеры использования и последствия  

6. **Сценарии нарушения целостности**  
   - Примеры «потерянных» ссылок, «зависших» записей  
   - Как диагностировать и исправлять нарушения  

7. **Лучшие практики проектирования**  
   - Правильное определение ключей и ограничений  
   - Минимизация риска нарушений при изменении схемы  
   - Тестирование целостности после миграций и обновлений  

8. **Практическая часть**  
   - Создание простых схем с родитель‑дочерними таблицами  
   - Выполнение операций вставки/обновления/удаления и наблюдение за реакцией БД  
   - Настройка и проверка правил ON DELETE/UPDATE  

Эти шаги помогут системно освоить концепцию ссылочной целостности, понять, как она реализуется в реальных БД, и научиться проектировать схемы, защищённые от нарушений.
**1. Название темы**  
*Связи и ключи в реляционных базах данных*

**2. Краткое описание темы**  
В этой теме рассматриваются фундаментальные механизмы, позволяющие в реляционной модели описывать взаимосвязи между таблицами. Мы изучаем, как первичные, потенциальные и составные ключи обеспечивают уникальность строк, как внешние ключи реализуют связи «один‑ко‑одному», «один‑ко‑многим» и «многие‑ко‑многим», а также как эти связи влияют на структуру и целостность данных.

**3. Подтемы / шаги изучения**

1. **Ключи в реляционной модели**  
   - Понятие первичного, потенциального (кандидатного) и альтернативного ключа  
   - Простые и составные ключи  

2. **Внешний ключ (Foreign Key)**  
   - Определение и назначение  
   - Свойства: простые/составные, домены, уникальность  
   - Ограничения целостности (ON DELETE, ON UPDATE)  

3. **Типы связей между сущностями**  
   - Один‑ко‑одному (1:1)  
   - Один‑ко‑многим (1:N)  
   - Многие‑ко‑многим (M:N) – реализация через промежуточную таблицу  

4. **Практическая реализация связей**  
   - Пример: сотрудники ↔ автомобили (1:1)  
   - Пример: отделы ↔ сотрудники (1:N)  
   - Пример: фильмы ↔ актеры (M:N)  

5. **Разделение таблиц: родительская и дочерняя**  
   - Хранение часто и редко используемых данных  
   - Принципы нормализации  

6. **Ограничения и целостность**  
   - Уникальность внешних ключей  
   - Каскадные операции и их влияние на данные  

7. **Практические упражнения**  
   - Создание схемы с разными типами связей  
   - Добавление и проверка внешних ключей  
   - Запросы, использующие JOIN‑ы для извлечения связанных данных  

Эти шаги помогут системно освоить, как в реляционных базах данных строятся и управляются связи между таблицами, а также как ключи обеспечивают целостность и уникальность данных.
**1. Название темы**  
*Основные операции реляционной алгебры*

**2. Краткое описание темы**  
В этой теме рассматриваются фундаментальные операции над отношениями, которые лежат в основе работы с реляционными базами данных: объединение, пересечение, разность, декартово произведение, соединение (join) и деление. Мы изучим их формальное определение, семантику, свойства, типичные примеры использования и способы оптимизации запросов.

**3. Подтемы / шаги изучения**

1. **Объединение (Union)**  
   - Формальное определение: \(R' = R \cup S\)  
   - Требования к совместимости (одинаковая структура)  
   - Удаление дубликатов  
   - Пример: объединение таблиц «Студенты 1» и «Студенты 2»  

2. **Пересечение (Intersection)**  
   - Формальное определение: \(R' = R \cap S\)  
   - Выбор строк, присутствующих в обеих таблицах  
   - Пример: студенты, сдающие оба экзамена  

3. **Разность (Difference)**  
   - Формальное определение: \(R' = R \setminus S\)  
   - Выбор строк из первой таблицы, которых нет во второй  
   - Пример: строки, отсутствующие во второй таблице  

4. **Декартово произведение (Cartesian Product)**  
   - Формальное определение: \(R' = R \times S\)  
   - Создание всех возможных сочетаний строк  
   - Пример: соединение студентов с дисциплинами  

5. **Соединение (Join)**  
   - Формальное определение: \(R' = R \bowtie_S\) (условие соединения)  
   - Расширенное декартово произведение + фильтрация по условию  
   - Типы соединений: внутреннее (inner), внешнее (left/right/full)  
   - Пример: связь таблиц преподавателей и кафедр  

6. **Деление (Division)**  
   - Формальное определение: \(R' = R \div S\)  
   - Выбор строк из \(R\), которые связаны со всеми строками \(S\)  
   - Пример: студенты, которые изучают все дисциплины из списка  

Каждый пункт можно дополнить таблицами, схемами и SQL‑эквивалентами для закрепления материала.
**1. Название темы**  
*ER‑моделирование и нормализация в проектировании баз данных*

**2. Краткое описание темы**  
В этой теме рассматривается полный цикл создания модели данных: от анализа предметной области и построения концептуальной ER‑диаграммы до её преобразования в физическую схему, применяемую в конкретной СУБД (например, MySQL Workbench). Особое внимание уделяется нормализации отношений, разбору связей «многие‑ко‑многим», а также практическим аспектам работы с атрибутами, внешними ключами и ограничениями целостности.

**3. Подтемы / шаги изучения**

1. **Анализ предметной области**  
   - Сбор требований и определение бизнес‑процессов.  
   - Выделение потенциальных сущностей (покупатель, товар, накладная, склад и т.д.).  
   - Определение атрибутов каждой сущности.

2. **Построение концептуальной ER‑диаграммы**  
   - Рисование сущностей, атрибутов и связей.  
   - Разделение «многие‑ко‑многим» на две связи «один‑ко‑многим» с помощью вспомогательных сущностей.  
   - Уточнение связей (модальность «должен» и т.п.) через итеративный диалог с экспертами.

3. **Преобразование в физическую ER‑диаграмму**  
   - Перевод сущностей в таблицы, атрибутов в колонки.  
   - Добавление ключевых атрибутов родительских таблиц в дочерние (для внешних ключей).  
   - Учет ограничений СУБД: типы данных, имена, ограничения целостности.

4. **Нормализация отношений**  
   - Применение нормальных форм (1NF, 2NF, 3NF и т.д.).  
   - Проверка на избыточность и аномалии обновления.  
   - Пример нормализации: таблицы «receipt_detail», «product_in_warehouse».

5. **Практическая работа в MySQL Workbench**  
   - Создание модели в Workbench.  
   - Генерация SQL‑скриптов для создания схемы.  
   - Тестирование целостности и производительности.

6. **Проверка и валидация модели**  
   - Сценарии тестирования (добавление, обновление, удаление записей).  
   - Анализ влияния изменений на связанные таблицы.  
   - Итеративное улучшение модели на основе результатов тестов.

7. **Документирование и передача модели**  
   - Создание описания схемы для разработчиков и администраторов.  
   - Подготовка схемы к импорту в другие СУБД при необходимости.  

Эти шаги обеспечат системный подход к проектированию баз данных, позволяя создавать эффективные, масштабируемые и легко поддерживаемые информационные системы.
**1. Название темы**  
Нормализация реляционных таблиц: функциональные зависимости и нормальные формы  

**2. Краткое описание темы**  
В рамках этой темы студенты изучают фундаментальные принципы нормализации баз данных. Мы разберём, как определить потенциальный ключ, выявить и классифицировать функциональные зависимости, а также как применять правила первой, второй и третьей нормальных форм (1NF, 2NF, 3NF). Через конкретный пример таблицы «Сотрудники‑Отделы‑Проекты‑Задачи» показано, как правильно декомпозировать отношение, устраняя частичные и транзитивные зависимости, и как проверить, что полученные таблицы находятся в нужных нормальных формах.  

**3. Подтемы / шаги изучения**  

| Шаг | Тема | Ключевые вопросы / задачи |
|-----|------|---------------------------|
| 1 | **Потенциальный ключ** | Что такое потенциальный ключ? Как определить его в отношении? Как проверить уникальность и минимальность? |
| 2 | **Функциональные зависимости (FD)** | Как записываем FD? Что такое неприводимая (полная) зависимость? Как отличить ключевые и неключевые атрибуты? |
| 3 | **Первая нормальная форма (1NF)** | Какие требования к 1NF? Как проверить, что отношение находится в 1NF? |
| 4 | **Вторая нормальная форма (2NF)** | Что такое частичная зависимость? Как выявить и устранить её? Как определить, что отношение уже в 2NF? |
| 5 | **Третья нормальная форма (3NF)** | Что такое транзитивная зависимость? Как проверить 3NF? Как декомпозировать отношение, чтобы убрать транзитивные зависимости? |
| 6 | **Алгоритм декомпозиции** | Как разложить отношение на несколько таблиц, сохраняя данные и зависимости? Как проверить, что декомпозиция сохраняет функциональные зависимости? |
| 7 | **Практический пример** | Исходное отношение: `СОТРУДНИКИ_ОТДЕЛЫ_ПРОЕКТЫ`. <br> • Выявляем FD: <br> {НОМЕР_СОТРУДНИКА, НОМЕР_ПРОЕКТА} → ФАМИЛИЯ, НОМЕР_ОТДЕЛА, ТЕЛЕФОН, ПРОЕКТ, НОМЕР_ЗАДАЧИ <br> НОМЕР_СОТРУДНИКА → ФАМИЛИЯ, НОМЕР_ОТДЕЛА, ТЕЛЕФОН <br> НОМЕР_ПРОЕКТА → ПРОЕКТ <br> НОМЕР_ОТДЕЛА → ТЕЛЕФОН <br> • Декомпозиция: <br> `СОТРУДНИКИ` (НОМЕР_СОТРУДНИКА, ФАМИЛИЯ, НОМЕР_ОТДЕЛА, ТЕЛЕФОН) <br> `ОТДЕЛЫ` (НОМЕР_ОТДЕЛА, ТЕЛЕФОН) <br> `ПРОЕКТЫ` (НОМЕР_ПРОЕКТА, ПРОЕКТ) <br> `ЗАДАЧИ` (НОМЕР_СОТРУДНИКА, НОМЕР_ПРОЕКТА, НОМЕР_ЗАДАЧИ) <br> • Проверяем, что каждая таблица находится в 2NF/3NF. |
| 8 | **Проверка нормальных форм после декомпозиции** | Как убедиться, что каждая новая таблица удовлетворяет 1NF, 2NF и 3NF? Какие критерии использовать? |
| 9 | **Практические упражнения** | • Анализировать заданные таблицы, выявлять FD и потенциальные ключи. <br>• Декомпозировать таблицы, чтобы достичь 3NF. <br>• Оценить, сохраняется ли целостность данных после декомпозиции. |
|10 | **Расширение** | Кратко упомянуть 4NF (независимость многозначных зависимостей) и 5NF (разложение по проекционным зависимостям) для тех, кто хочет углубиться. |

Эта структура позволяет последовательно перейти от теоретических основ до практического применения нормализации на реальном примере, закрепляя навыки анализа зависимостей и проектирования корректных схем баз данных.
**1. Название темы**  
Типы данных в SQL: числовые, логические, битовые и строковые

**2. Краткое описание темы**  
В этой теме рассматриваются основные категории типов данных, используемых в системах управления базами данных (СУБД). Мы изучим, как СУБД определяют точность и диапазон значений, какие особенности имеют логические типы, как хранится двоичная информация и какие варианты строковых типов позволяют экономить место и обеспечивать гибкость. Понимание этих концепций поможет правильно проектировать схемы таблиц, оптимизировать хранение данных и писать корректные запросы.

**3. Подтемы / шаги изучения**

1. **Числовые типы**  
   1.1. *Плавающие типы* – `REAL`, `FLOAT[(n)]`  
   1.2. *Точные типы* – `NUMERIC[(n[,m])]`, `DECIMAL[(n[,m])]`, `DEC[(n[,m])]`  
   1.3. *Целочисленные типы* – `BIGINT`, `INTEGER`, `SMALLINT`  
   1.4. Диапазоны значений и влияние версии СУБД на точность  

2. **Логический тип**  
   2.1. `BOOLEAN` в SQL: `TRUE`, `FALSE`, `UNKNOWN` (NULL)  
   2.2. Отличия от логических типов в языках программирования  
   2.3. Практические примеры использования в условиях (`WHERE`, `CASE`)  

3. **Битовые последовательности**  
   3.1. `BIT(n)` – фиксированная длина, правила заполнения  
   3.2. `VARBIT` / `BINARY` – переменная длина и хранение больших объектов  
   3.3. Применение: хранение флагов, бинарных файлов, криптографических ключей  

4. **Строковые типы**  
   4.1. `CHAR(n)` – фиксированная длина, заполнение пробелами  
   4.2. `VARCHAR(n)` – переменная длина, экономия места  
   4.3. Ограничения и особенности при работе с текстом (кодировка, сравнение)  

5. **Практические задания**  
   5.1. Выбор подходящего типа данных для конкретных сценариев  
   5.2. Анализ влияния выбора типа на производительность и размер БД  
   5.3. Конвертация данных между типами и обработка ошибок  

6. **Дополнительные темы (по желанию)**  
   6.1. Хранение больших объектов: `BLOB`, `CLOB`  
   6.2. Пользовательские типы данных и расширения СУБД  

Эта структура поможет систематически освоить типы данных в SQL, их свойства и практическое применение.
**1. Название темы**  
*SQL‑подзапросы, фильтрация и базовые операции вставки/представлений*

**2. Краткое описание темы**  
В этой теме рассматриваются ключевые конструкции языка SQL, которые позволяют формировать сложные запросы к базе данных: подзапросы (скалярные и табличные), условия фильтрации в предложении `WHERE` (сравнение, диапазон, шаблоны, NULL‑проверка, `EXISTS`/`IN`), более продвинутые предикаты `ALL`/`ANY`, а также основы вставки данных (`INSERT`) и создания представлений (`VIEW`). Понимание этих механизмов даёт возможность писать эффективные, читаемые и поддерживаемые запросы.

**3. Подтемы / шаги изучения**

| № | Подтема | Краткое содержание |
|---|---------|---------------------|
| 1 | **Типы подзапросов** | Скалярные vs табличные; правила использования в `SELECT`, `WHERE`, `FROM`. |
| 2 | **Ограничения подзапросов** | `ORDER BY` в подзапросах, список `SELECT`, квалификация столбцов, правила расположения в операциях сравнения. |
| 3 | **Фильтрация данных – `WHERE`** | Сравнение, диапазон, шаблоны (`LIKE`), проверка `NULL`, логические операторы (`AND`, `OR`, `NOT`). |
| 4 | **Проверка существования – `EXISTS` vs `IN`** | Синтаксис, семантика, производительность, примеры (товары с заказами). |
| 5 | **Многократное сравнение – `ALL`, `ANY`/`SOME`** | Как работают предикаты, примеры использования вместо `IN`. |
| 6 | **Вставка данных – `INSERT`** | Стандартный синтаксис, добавление одной строки, массовая вставка через `SELECT`, автоинкрементные ключи. |
| 7 | **Создание представлений – `VIEW`** | Синтаксис `CREATE VIEW`, опции `OR REPLACE`, `ALGORITHM`, `CHECK OPTION`; преимущества представлений. |
| 8 | **Практические задания** | 1) Написать запрос с `EXISTS` для поиска товаров без заказов. 2) Переписать тот же запрос с `IN`. 3) Создать представление, объединяющее таблицы `products` и `orders`. 4) Вставить несколько строк через `INSERT … SELECT`. |

Эта структура позволяет последовательно освоить как теоретические основы, так и практические навыки работы с SQL‑запросами.
**1. Название темы**  
Индексы в СУБД: B‑деревья и хеш‑индексы  

**2. Краткое описание темы**  
В этой теме рассматриваются основные типы индексов, используемых в реляционных системах управления базами данных (СУБД). Особое внимание уделяется структурам B‑деревьев и хеш‑таблиц, их внутреннему устройству, алгоритмам поиска, вставки и удаления, а также преимуществам и ограничениям каждого подхода. Тема охватывает как теоретические основы, так и практические аспекты создания, обслуживания и выбора индекса в зависимости от требований к запросам и объёма данных.  

**3. Подтемы / шаги изучения**  

1. **Введение в индексы**  
   - Что такое индекс и зачем он нужен в СУБД  
   - Роль индексов в ускорении запросов и поддержке уникальности  

2. **Общие принципы работы индексов**  
   - Структура индекса: ключи и указатели  
   - Как индексы взаимодействуют с таблицами (primary, foreign, user‑defined)  

3. **B‑деревья (B‑tree)**  
   - Сбалансированная структура и её свойства  
   - Алгоритм поиска, вставки и удаления в B‑дереве  
   - Пошаговый поиск по полному значению, префиксу, диапазону  
   - Поддержка составных ключей и ограничения (необходимость использования левой части)  
   - Влияние на производительность: одинаковое число переходов, возможность работы без чтения строк  

4. **Хеш‑индексы (hash)**  
   - Принцип хеш‑функции и распределения ключей  
   - Быстрый доступ при равенстве, но отсутствие упорядоченности  
   - Ограничения: невозможность поиска по диапазону, частичному ключу, сортировки  
   - Коллизии: цепочки и их влияние на скорость поиска  

5. **Сравнение B‑tree и hash‑индексов**  
   - Краткие таблицы преимуществ/недостатков  
   - Когда выбирать B‑tree, а когда hash  
   - Примеры типовых запросов и их эффективность  

6. **Другие типы индексов (кратко)**  
   - Пространственные индексы (R‑tree, Spatial grid)  
   - Битовые индексы  
   - Полнотекстовые индексы  

7. **Обслуживание и обновление индексов**  
   - Влияние вставок/обновлений/удалений на размер и структуру индекса  
   - Перестройка индекса, балансировка, реорганизация  
   - Профилирование и мониторинг производительности  

8. **Практические рекомендации**  
   - Как определить, какие столбцы индексировать  
   - Оптимизация составных индексов (порядок ключей)  
   - Балансировка между размером индекса и временем выполнения запросов  

9. **Заключение**  
   - Краткое резюме ключевых выводов  
   - Перспективы развития индексов в современных СУБД  

Эта структура позволит последовательно освоить как теоретические основы, так и практические навыки работы с индексами в реальных базах данных.
**1. Название темы**  
*Пространственный анализ в SQL: работа с геометрией и пространственными операциями*

**2. Краткое описание темы**  
В рамках данной темы изучаются основные возможности работы с геометрическими объектами в реляционных базах данных. Рассматриваются форматы представления геометрии (WKT, WKB, GeoJSON, GML), типы пространственных данных (POINT, LINESTRING, POLYGON, GEOMETRYCOLLECTION), функции создания и преобразования геометрии, пространственные операции (объединение, разность, симметричная разность), определение пространственных отношений (пересечение, принадлежность, соседство), а также инструменты ускорения запросов – пространственные индексы. Особое внимание уделяется стандартам OGC и расширениям PostGIS, а также реализации пространственных типов в MySQL.

**3. Подтемы / шаги изучения**

1. **Введение в пространственные данные**  
   - Что такое геометрия и зачем она нужна в БД  
   - Краткая история и роль OGC  

2. **Форматы представления геометрии**  
   - WKT (Well‑Known Text) – синтаксис и примеры  
   - WKB (Well‑Known Binary) – бинарный эквивалент  
   - GeoJSON и GML – текстовые форматы для обмена данными  

3. **Типы пространственных данных в SQL**  
   - GEOMETRY (абстрактный тип)  
   - POINT, LINESTRING, POLYGON, GEOMETRYCOLLECTION  
   - Примеры создания объектов через функции `ST_GeomFromText`, `ST_LineFromText`, `ST_GeomCollFromText`  

4. **Функции преобразования и получения описания**  
   - `ST_AsText`, `ST_AsGeoJSON`, `ST_AsGML`  
   - `ST_GeomFromGeoJSON`, `ST_GeomFromGML`  

5. **Пространственные операции над геометрией**  
   - Объединение: `ST_Union`  
   - Разность: `ST_Difference`  
   - Симметричная разность: `ST_SymDifference`  
   - Примеры запросов и визуализация результатов  

6. **Определение пространственных отношений**  
   - `ST_Intersects`, `ST_Contains`, `ST_Within`, `ST_Touches`  
   - Практика: проверка пересечения земельных участков, нахождение объектов внутри района  

7. **Пространственные индексы и производительность**  
   - Создание индексов `SPATIAL INDEX` в MySQL  
   - Как индексы ускоряют запросы с геометрией  

8. **Расширения PostGIS и их возможности**  
   - Установка и настройка PostGIS  
   - Дополнительные типы и функции (raster, topology)  
   - Примеры сложных пространственных запросов  

9. **Стандарты OGC и их применение**  
   - Simple Features Specification for SQL  
   - GML, SRID, WKT, WKB – как они соотносятся с реализацией в СУБД  

10. **Практическое задание**  
    - Создание таблицы с геометрическими данными  
    - Выполнение набора запросов: создание, преобразование, операции, индексация  
    - Анализ производительности и оптимизация  

Эта структура позволит последовательно освоить все ключевые аспекты работы с пространственными данными в SQL‑базах, от базовых понятий до продвинутых техник анализа и оптимизации.
**1. Название темы**  
*Триггеры, функции и хранимые процедуры в SQL (MySQL)*  

**2. Краткое описание темы**  
В этой теме рассматриваются ключевые механизмы расширения функциональности СУБД через серверные объекты: триггеры, функции и хранимые процедуры. Вы изучите, как объявлять, изменять и удалять эти объекты, как управлять их порядком выполнения, какие типы событий поддерживаются, а также различия между триггерами и процедурами. Практические примеры на MySQL помогут закрепить синтаксис и понять, как использовать эти инструменты для обеспечения целостности данных, автоматизации бизнес‑логики и повышения производительности запросов.  

**3. Подтемы / шаги изучения**  

| № | Подтема | Краткое содержание |
|---|---------|---------------------|
| 1 | **Введение в серверные объекты** | Что такое триггеры, функции и процедуры; зачем они нужны; основные отличия. |
| 2 | **Триггеры: типы и порядок** | BEFORE/AFTER, INSERT/UPDATE/DELETE, FOLLOWS/PRECEDES; как задавать порядок выполнения. |
| 3 | **Синтаксис создания триггера в MySQL** | `CREATE TRIGGER …` – ключевые слова, параметры, тело триггера. |
| 4 | **Функции: создание и вызов** | `CREATE FUNCTION …` – параметры, тип возвращаемого значения, оператор `RETURN`; вызов в `SELECT`. |
| 5 | **Хранимые процедуры: синтаксис и характеристики** | `CREATE PROCEDURE …` – параметры (`IN`, `OUT`, `INOUT`), `COMMENT`, `DETERMINISTIC`, `SQL SECURITY`, тело. |
| 6 | **Изменение и удаление объектов** | `ALTER PROCEDURE/FUNCTION …`, `DROP PROCEDURE/FUNCTION …`; как «пересоздать» объект. |
| 7 | **Сравнение триггеров и процедур** | Когда использовать каждый тип, ограничения, влияние на клиентские приложения. |
| 8 | **Практические примеры** | 1) Триггер, проверяющий условия вставки/обновления. 2) Функция подсчёта заказов товара. 3) Процедура расчёта стоимости с циклом `WHILE`. |
| 9 | **Оптимизация и безопасность** | Как избежать рекурсивных триггеров, использовать `READS SQL DATA` vs `MODIFIES SQL DATA`, роль `SQL SECURITY`. |
|10 | **Тестирование и отладка** | Как логировать срабатывания, использовать `SHOW TRIGGERS`, `SHOW CREATE FUNCTION/PROCEDURE`. |

Эта структура позволит последовательно освоить все аспекты работы с триггерами, функциями и процедурами в MySQL, от базового синтаксиса до продвинутых техник управления порядком и безопасностью.
**1. Название темы**  
*CAP, PACELC и BASE: компромиссы в распределённых системах*

**2. Краткое описание темы**  
В этой теме рассматриваются фундаментальные принципы проектирования распределённых вычислительных систем, которые ограничивают возможные комбинации свойств согласованности, доступности и устойчивости к разделению. Мы изучим классическую теорему CAP, её расширения (PACELC, BASE), примеры реальных систем и критические замечания к этим моделям. Цель – понять, какие компромиссы необходимо делать при проектировании и эксплуатации распределённых БД и сервисов, и как выбирать оптимальный баланс между согласованностью, доступностью и задержкой.

**3. Подтемы / шаги изучения**

| Шаг | Подтема | Краткое содержание |
|-----|---------|---------------------|
| 1 | **Введение в CAP** | История формулировки (Bray, 2000), основные понятия: Consistency, Availability, Partition Tolerance. |
| 2 | **Классы распределённых систем** | CA, CP, AP – примеры, характеристики, ограничения. LDAP, реляционные БД (CA); Cassandra, DynamoDB (AP); традиционные ACID‑БД (CP). |
| 3 | **Расширения теоремы** | PACELC – добавление параметров Latency и Else‑case; BASE – Basically Available, Soft‑state, Eventually Consistent. Сравнение с CAP. |
| 4 | **Критика и альтернативы** | Ограничения CAP как упрощённого маркетингового термина, проблемы с точными определениями, необходимость более точных моделей (например, Consistency‑Latency‑Availability‑Partition). |
| 5 | **Практические примеры** | LDAP, реляционные БД, NoSQL‑системы (Cassandra, Riak, DynamoDB). Как они реализуют компромиссы. |
| 6 | **Методы выбора компромисса** | Анализ требований к бизнес‑логике: нужна ли строгая согласованность, какова допустимая задержка, как реагировать на сетевые разделения. |
| 7 | **Инструменты и метрики** | Методы измерения согласованности (Read‑Your‑Own‑Writes, Monotonic Reads), измерения доступности (Uptime, SLA), измерения задержки (Latency, Jitter). |
| 8 | **Кейс‑стади** | Практическое разбор конкретных сценариев: миграция от реляционной БД к NoSQL, настройка Cassandra для балансировки C vs. L. |
| 9 | **Обобщение и выводы** | Как использовать CAP/PACELC/BASE в реальном проектировании, какие «правильные» компромиссы возможны, и как оценивать их эффективность. |

Эта структура позволяет последовательно погрузиться в теоретические основы, увидеть их применение в реальных системах и научиться принимать обоснованные решения при проектировании распределённых сервисов.
**1. Название темы**  
*Документ‑ориентированные NoSQL‑СУБД: основы MongoDB*

**2. Краткое описание темы**  
В этой теме рассматриваются ключевые особенности документ‑ориентированной базы данных MongoDB – от модели хранения данных и типовой схемы до механизмов индексации, представлений и транзакций. Сравнение с реляционными СУБД позволяет понять, какие преимущества и ограничения предоставляет MongoDB в современных приложениях.

**3. Подтемы / шаги изучения**

| № | Подтема | Краткое содержание |
|---|---------|---------------------|
| 1 | Введение в NoSQL и MongoDB | Что такое NoSQL, основные типы (ключ‑значение, колоночные, графовые, документ‑ориентированные); история и позиционирование MongoDB. |
| 2 | Архитектура MongoDB | Кроссплатформенность, открытый исходный код, репликация, шардирование, распределённость. |
| 3 | Модель данных MongoDB | База данных → Коллекция → Документ → Поле; сравнение с таблицами, строками и столбцами в реляционных СУБД. |
| 4 | Документы и BSON | Формат хранения, поддерживаемые типы данных (null, логический, число, строка, массив, объект, дополнительные типы MongoDB). Ограничения размера документа (16 МБ). |
| 5 | Индексирование и поиск | Создание индексов (`createIndex`), типы индексов (уникальные, композитные), параметры (`name`, `unique`, `commitQuorum`). |
| 6 | Представления и агрегации | Создание `views` через `createView`, конвейер агрегации, преимущества представлений (фильтрация, вычисляемые поля). |
| 7 | Транзакции в MongoDB | ACID‑совместимые транзакции, два API (базовый и callback‑стиль), ограничения и производительность при работе с репликами и шардированными коллекциями. |
| 8 | Сравнение с реляционными СУБД | Таблица сопоставления ключевых понятий, различия в схеме, JOIN vs `$lookup`, преимущества денормализации и гибкости схемы. |
| 9 | Практические рекомендации | Лучшие практики проектирования схемы, индексации, управления транзакциями, масштабирования и мониторинга. |
|10 | Кейсы и примеры | Примеры реальных сценариев использования MongoDB: логирование, аналитика, хранение больших JSON‑объектов. |

Эта структура позволит последовательно освоить все важные аспекты MongoDB и понять, как применять их в реальных проектах.
**1. Название темы**  
*Агрегация и обновление данных в MongoDB*

**2. Краткое описание темы**  
В этой теме рассматриваются основные механизмы работы с данными в MongoDB: как фильтровать, группировать, соединять и обновлять документы. Особое внимание уделяется конвейеру агрегации (`aggregate`) и его этапам (`$match`, `$group`, `$lookup`, `$limit` и др.), а также методам обновления (`updateOne`, `updateMany`, `replaceOne`). Понимание этих инструментов позволяет выполнять сложные аналитические запросы и поддерживать актуальность коллекций.

**3. Подтемы / шаги изучения**

| Шаг | Тема | Краткое содержание |
|-----|------|---------------------|
| 1 | **Основы фильтрации** | `find` с пустым фильтром, синтаксис условий, операторы сравнения, логические операторы, работа с массивами. |
| 2 | **Методы подсчёта и уникальных значений** | `count()`, `estimatedDocumentCount()`, `distinct()`. Примеры эквивалентных SQL‑запросов. |
| 3 | **Методы обновления документов** | `updateOne`, `updateMany`, `replaceOne`; параметры фильтра, обновления, опции (`upsert`, `writeConcern`, `collation`, `arrayFilters`). |
| 4 | **Конвейер агрегации – ввод** | Что такое pipeline, как он передаётся в `aggregate(pipeline, options)`. |
| 5 | **Этапы конвейера** | • `$match` – фильтрация документов.<br>• `$group` – группировка и агрегатные функции (avg, max, min, sum).<br>• `$lookup` – левое внешнее соединение.<br>• `$limit` – ограничение количества документов.<br>• Другие стадии (не упомянутые в тексте, но полезные: `$project`, `$sort`, `$unwind`). |
| 6 | **Агрегация как средство обновления** | Начиная с MongoDB 4.2, `aggregate` может использоваться для обновления документов. Пример использования. |
| 7 | **Практические примеры** | 1. Выбор всех документов (`find({})`).<br>2. Получение уникальных статусов (`distinct("status")`).<br>3. Группировка по полю и вычисление среднего.<br>4. Объединение коллекций через `$lookup`. |
| 8 | **Оптимизация и индексы** | Как индексы влияют на `$match`, `$group`, `$lookup`. |
| 9 | **Параметры `aggregate`** | `allowDiskUse`, `batchSize`, `collation`, `maxTimeMS`. |
|10 | **Сравнение с SQL** | Как эквивалентные операции реализуются в MongoDB и какие преимущества/ограничения. |

Эта структура позволяет последовательно освоить как базовые операции, так и продвинутые техники работы с данными в MongoDB.
